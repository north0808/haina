<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Qt Cryptographic Architecture: QCA::SyncThread Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceQCA.html">QCA</a>::<a class="el" href="classQCA_1_1SyncThread.html">SyncThread</a>
  </div>
</div>
<div class="contents">
<h1>QCA::SyncThread Class Reference<br>
<small>
[<a class="el" href="group__UserAPI.html">QCA user API</a>]</small>
</h1><!-- doxytag: class="QCA::SyncThread" --><!-- doxytag: inherits="QThread" -->Convenience class to run a thread and interact with it synchronously.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="qca__support_8h-source.html">QtCrypto</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for QCA::SyncThread:</div>
<div class="dynsection">

<p><center><img src="classQCA_1_1SyncThread.png" usemap="#QCA::SyncThread_map" border="0" alt=""></center>
<map name="QCA::SyncThread_map">
<area doxygen="qt.tag:" href="qthread.html" alt="QThread" shape="rect" coords="0,0,115,24">
</map>
</div>
<div class="dynheader">
Collaboration diagram for QCA::SyncThread:</div>
<div class="dynsection">
<p><center><img src="classQCA_1_1SyncThread__coll__graph.png" border="0" usemap="#QCA_1_1SyncThread__coll__map" alt="Collaboration graph"></center>
<map name="QCA_1_1SyncThread__coll__map">
<area shape="rect" doxygen="qt.tag:" href="qthread.html" title="QThread" alt="" coords="5,6,77,30"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classQCA_1_1SyncThread-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#50df14a38deac80c42f17c3e968e52bb">call</a> (<a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *obj, const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;method, const QVariantList &amp;args=QVariantList(), bool *ok=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#f2ad952e1f3e10173e467b52791baeee">start</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#77113f4ec74348dc41263568509f4e38">stop</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#2b4f99a230cd531f61c1c7e594378748">SyncThread</a> (<a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *parent=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#02de52337dce055bf62af4ff0b9da867">~SyncThread</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#cddee6d75a49c66bc4420cb565e5b896">atEnd</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#0e5de741e3c0e2056469fd77849b7abd">atStart</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#3432c746333edded144a5d43576d1012">run</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c96b60d37bd806132da680e187dc2288"></a><!-- doxytag: member="QCA::SyncThread::Private" ref="c96b60d37bd806132da680e187dc2288" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Private</b></td></tr>

<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">QCA_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#0493eb0b640e8d3a275d26c6706a1a6e">invokeMethodWithVariants</a> (<a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *obj, const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;method, const QVariantList &amp;args, <a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> *ret, Qt::ConnectionType type=Qt::AutoConnection)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">QCA_EXPORT <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCA_1_1SyncThread.html#489c4d656b533b3e0f033d5c035421d7">methodReturnType</a> (const <a class="elRef" doxygen="qt.tag:" href="qmetaobject.html">QMetaObject</a> *obj, const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;method, const <a class="elRef" doxygen="qt.tag:" href="qlist.html">QList</a>&lt; <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &gt; argTypes)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Convenience class to run a thread and interact with it synchronously. 
<p>
<a class="el" href="classQCA_1_1SyncThread.html" title="Convenience class to run a thread and interact with it synchronously.">SyncThread</a> makes it easy to perform the common practice of starting a thread, running some objects in that thread, and then interacting with those objects safely. Often, there is no need to directly use threading primitives (e.g. <a class="elRef" doxygen="qt.tag:" href="qmutex.html">QMutex</a>), resulting in very clean multi-threaded code.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The following is an excerpt from <a href="http://delta.affinix.com/2006/11/13/synchronized-threads-part-3/">http://delta.affinix.com/2006/11/13/synchronized-threads-part-3/</a></dd></dl>
---<br>
 With <a class="el" href="classQCA_1_1SyncThread.html" title="Convenience class to run a thread and interact with it synchronously.">SyncThread</a>, you can start, stop, and call a method in another thread while the main thread sleeps. The only requirement is that the methods be declared as slots.<p>
Below is a contrived example, where we have an object in another thread that increments a counter over a some interval, using the Qt event loop, and provides a method to inspect the value.<p>
First, the Counter object:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Counter : <span class="keyword">public</span> <a class="codeRef" doxygen="qt.tag:" href="qobject.html">QObject</a>
{
        Q_OBJECT
<span class="keyword">private</span>:
        <span class="keywordtype">int</span> x;
        <a class="codeRef" doxygen="qt.tag:" href="qtimer.html">QTimer</a> timer;

<span class="keyword">public</span>:
        Counter() : timer(this)
        {
                x = 0;
                connect(&amp;timer, SIGNAL(timeout()), SLOT(t_timeout()));
        }

<span class="keyword">public</span> slots:
        <span class="keywordtype">void</span> <a class="code" href="classQCA_1_1SyncThread.html#f2ad952e1f3e10173e467b52791baeee" title="Starts the thread, begins the event loop the thread, and then calls atStart() in...">start</a>(<span class="keywordtype">int</span> seconds)
        {
                timer.setInterval(seconds * 1000);
                timer.start();
        }

        <span class="keywordtype">int</span> value()<span class="keyword"> const</span>
<span class="keyword">        </span>{
                <span class="keywordflow">return</span> x;
        }

<span class="keyword">private</span> slots:
        <span class="keywordtype">void</span> t_timeout()
        {
                ++x;
        }
};
</pre></div><p>
Looks like a typical object, no surprises.<p>
Now to wrap Counter with <a class="el" href="classQCA_1_1SyncThread.html" title="Convenience class to run a thread and interact with it synchronously.">SyncThread</a>. We went over how to do this in the first article, and it is very straightforward:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>CounterThread : <span class="keyword">public</span> <a class="code" href="classQCA_1_1SyncThread.html#2b4f99a230cd531f61c1c7e594378748" title="Standard constructor.">SyncThread</a>
{
        Q_OBJECT
<span class="keyword">public</span>:
        Counter *counter;

        CounterThread(<a class="codeRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *parent) : <a class="code" href="classQCA_1_1SyncThread.html#2b4f99a230cd531f61c1c7e594378748" title="Standard constructor.">SyncThread</a>(parent)
        {
                counter = 0;
        }

        ~CounterThread()
        {
                <span class="comment">// SyncThread will stop the thread on destruct, but since our</span>
                <span class="comment">//   atStop() function makes references to CounterThread's</span>
                <span class="comment">//   members, we need to shutdown here, before CounterThread</span>
                <span class="comment">//   destructs.</span>
                <a class="code" href="classQCA_1_1SyncThread.html#77113f4ec74348dc41263568509f4e38" title="Stops the event loop of the thread, calls atStop() in the thread, and instructs the...">stop</a>();
        }

<span class="keyword">protected</span>:
        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classQCA_1_1SyncThread.html#0e5de741e3c0e2056469fd77849b7abd" title="Reimplement this to perform your initialization.">atStart</a>()
        {
                counter = <span class="keyword">new</span> Counter;
        }

        <span class="keyword">virtual</span> <span class="keywordtype">void</span> atStop()
        {
                <span class="keyword">delete</span> counter;
        }
};
</pre></div><p>
We can then use it like this:<p>
<div class="fragment"><pre class="fragment">CounterThread *thread = <span class="keyword">new</span> CounterThread;

<span class="comment">// after this call, the thread is started and the Counter is ready</span>
thread-&gt;start();

<span class="comment">// let's start the counter with a 1 second interval</span>
thread-&gt;call(thread-&gt;counter, <span class="stringliteral">"start"</span>, QVariantList() &lt;&lt; 1);
...

<span class="comment">// after some time passes, let's check on the value</span>
int x = thread-&gt;call(thread-&gt;counter, <span class="stringliteral">"value"</span>).toInt();

<span class="comment">// we're done with this thing</span>
<span class="keyword">delete</span> thread;
</pre></div><p>
Do you see a mutex anywhere? I didn't think so.<br>
 ---<p>
Even without the <a class="el" href="classQCA_1_1SyncThread.html#50df14a38deac80c42f17c3e968e52bb" title="Calls a slot of an object in the thread.">call()</a> function, <a class="el" href="classQCA_1_1SyncThread.html" title="Convenience class to run a thread and interact with it synchronously.">SyncThread</a> is still very useful for preparing objects in another thread, which you can then <a class="elRef" doxygen="qt.tag:" href="qobject.html#connect">QObject::connect()</a> to and use signals and slots like normal. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="2b4f99a230cd531f61c1c7e594378748"></a><!-- doxytag: member="QCA::SyncThread::SyncThread" ref="2b4f99a230cd531f61c1c7e594378748" args="(QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA::SyncThread::SyncThread           </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>the parent object for this parent. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="02de52337dce055bf62af4ff0b9da867"></a><!-- doxytag: member="QCA::SyncThread::~SyncThread" ref="02de52337dce055bf62af4ff0b9da867" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA::SyncThread::~SyncThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="classQCA_1_1SyncThread.html#77113f4ec74348dc41263568509f4e38" title="Stops the event loop of the thread, calls atStop() in the thread, and instructs the...">stop()</a> and then destructs. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Subclasses should call <a class="el" href="classQCA_1_1SyncThread.html#77113f4ec74348dc41263568509f4e38" title="Stops the event loop of the thread, calls atStop() in the thread, and instructs the...">stop()</a> in their own destructor </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="cddee6d75a49c66bc4420cb565e5b896"></a><!-- doxytag: member="QCA::SyncThread::atEnd" ref="cddee6d75a49c66bc4420cb565e5b896" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QCA::SyncThread::atEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reimplement this to perform your deinitialization. 
<p>

</div>
</div><p>
<a class="anchor" name="0e5de741e3c0e2056469fd77849b7abd"></a><!-- doxytag: member="QCA::SyncThread::atStart" ref="0e5de741e3c0e2056469fd77849b7abd" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QCA::SyncThread::atStart           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reimplement this to perform your initialization. 
<p>

</div>
</div><p>
<a class="anchor" name="50df14a38deac80c42f17c3e968e52bb"></a><!-- doxytag: member="QCA::SyncThread::call" ref="50df14a38deac80c42f17c3e968e52bb" args="(QObject *obj, const QByteArray &amp;method, const QVariantList &amp;args=QVariantList(), bool *ok=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> QCA::SyncThread::call           </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantList &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em> = <code>QVariantList()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>ok</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a slot of an object in the thread. 
<p>
This function will block until the slot has returned.<p>
It is possible for the call to fail, for example if the method does not exist.<p>
The arguments and return value of the call use <a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a>. If the method has no return value (returns void), then the returned <a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> will be null.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>the object to call the method on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the method (without the arguments or brackets) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>the list of arguments to use in the method call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ok</em>&nbsp;</td><td>if not 0, true is stored here if the call succeeds, otherwise false is stored here. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3432c746333edded144a5d43576d1012"></a><!-- doxytag: member="QCA::SyncThread::run" ref="3432c746333edded144a5d43576d1012" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QCA::SyncThread::run           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts the event loop and calls atStart and atStop as necessary. 
<p>

<p>Reimplemented from <a class="elRef" doxygen="qt.tag:" href="qthread.html#run">QThread</a>.</p>

</div>
</div><p>
<a class="anchor" name="f2ad952e1f3e10173e467b52791baeee"></a><!-- doxytag: member="QCA::SyncThread::start" ref="f2ad952e1f3e10173e467b52791baeee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCA::SyncThread::start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts the thread, begins the event loop the thread, and then calls <a class="el" href="classQCA_1_1SyncThread.html#0e5de741e3c0e2056469fd77849b7abd" title="Reimplement this to perform your initialization.">atStart()</a> in the thread. 
<p>
This function will block until <a class="el" href="classQCA_1_1SyncThread.html#0e5de741e3c0e2056469fd77849b7abd" title="Reimplement this to perform your initialization.">atStart()</a> has returned. 
</div>
</div><p>
<a class="anchor" name="77113f4ec74348dc41263568509f4e38"></a><!-- doxytag: member="QCA::SyncThread::stop" ref="77113f4ec74348dc41263568509f4e38" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCA::SyncThread::stop           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops the event loop of the thread, calls atStop() in the thread, and instructs the thread to finish. 
<p>
This function will block until the thread has finished. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="0493eb0b640e8d3a275d26c6706a1a6e"></a><!-- doxytag: member="QCA::SyncThread::invokeMethodWithVariants" ref="0493eb0b640e8d3a275d26c6706a1a6e" args="(QObject *obj, const QByteArray &amp;method, const QVariantList &amp;args, QVariant *ret, Qt::ConnectionType type=Qt::AutoConnection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA_EXPORT bool invokeMethodWithVariants           </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tag:" href="qobject.html">QObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantList &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> *&nbsp;</td>
          <td class="paramname"> <em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::ConnectionType&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>Qt::AutoConnection</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method to invoke a method by name, using a variant list of arguments. 
<p>
This function can be used as shown: <div class="fragment"><pre class="fragment"><span class="keyword">class </span>TestClass : <span class="keyword">public</span> <a class="codeRef" doxygen="qt.tag:" href="qobject.html">QObject</a>
{
    Q_OBJECT
    <span class="comment">// ...</span>
<span class="keyword">public</span> slots:
    <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> qstringMethod()  { <span class="keywordflow">return</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a>( <span class="stringliteral">"the result"</span> ); };
    <span class="keywordtype">bool</span> boolMethod( <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp; )  { <span class="keywordflow">return</span> <span class="keyword">true</span>; };
};

TestClass *testClass = <span class="keyword">new</span> TestClass;
QVariantList args;

<a class="codeRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> stringRes;
<span class="comment">// calls testClass-&gt;qstringMethod() with no arguments ( since args is an empty list)</span>
<span class="keywordtype">bool</span> ret = QCA::invokeMethodWithVariants( testClass, <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">"qstringMethod"</span> ), args, &amp;stringRes );
<span class="comment">// ret is true (since call succeeded), stringRes.toString() is a string - "the result"</span>

<a class="codeRef" doxygen="qt.tag:" href="qvariant.html">QVariant</a> boolResult;
<a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> someString( <span class="stringliteral">"not important"</span> );
args &lt;&lt; someString;
<span class="comment">// calls testClass-&gt;boolMethod( someString ), returning result in boolResult</span>
ret = QCA::invokeMethodWithVariants( testClass1, <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">"boolMethod"</span> ), args, &amp;boolResult );
<span class="comment">// ret is true (since call succeeded), boolResult.toBool() is true.</span>
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>the object to call the method on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the method (without the arguments or brackets) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>the list of arguments to use in the method call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ret</em>&nbsp;</td><td>the return value of the method (unchanged if the call fails) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type of connection to use</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the call succeeded, otherwise false </dd></dl>

</div>
</div><p>
<a class="anchor" name="489c4d656b533b3e0f033d5c035421d7"></a><!-- doxytag: member="QCA::SyncThread::methodReturnType" ref="489c4d656b533b3e0f033d5c035421d7" args="(const QMetaObject *obj, const QByteArray &amp;method, const QList&lt; QByteArray &gt; argTypes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCA_EXPORT <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> methodReturnType           </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qmetaobject.html">QMetaObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="qt.tag:" href="qlist.html">QList</a>&lt; <a class="elRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>argTypes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method to determine the return type of a method. 
<p>
This function identifies the return type of a specified method. This function can be used as shown: <div class="fragment"><pre class="fragment"><span class="keyword">class </span>TestClass : <span class="keyword">public</span> <a class="codeRef" doxygen="qt.tag:" href="qobject.html">QObject</a>
{
    Q_OBJECT
    <span class="comment">// ...</span>
<span class="keyword">public</span> slots:
    <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> qstringMethod()  { <span class="keywordflow">return</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a>(); };
    <span class="keywordtype">bool</span> boolMethod( <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp; )  { <span class="keywordflow">return</span> <span class="keyword">true</span>; };
};

<a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> myTypeName;

TestClass testClass;
<a class="codeRef" doxygen="qt.tag:" href="qlist.html">QList&lt;QByteArray&gt;</a> argsList; <span class="comment">// empty list, since no args</span>

myTypeName = QCA::methodReturnType( testClass.metaObject(), <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">"qstringMethod"</span> ), argsList );
<span class="comment">// myTypeName is "QString"</span>

myTypeName = QCA::methodReturnType( testClass.metaObject(), <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">"boolMethod"</span> ), argsList );
<span class="comment">// myTypeName is "", because there is no method called "boolMethod" that has no arguments</span>

argsList &lt;&lt; <span class="stringliteral">"QString"</span>; <span class="comment">// now we have one argument</span>
myTypeName = QCA::methodReturnType( testClass.metaObject(), <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a>( <span class="stringliteral">"boolMethod"</span> ), argsList );
<span class="comment">// myTypeName is "bool"</span>
</pre></div><p>
The return type name of a method returning void is an empty string, not "void"<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is not normally required for use with QCA. It is provided for use in your code, if required.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>the <a class="elRef" doxygen="qt.tag:" href="qmetaobject.html">QMetaObject</a> for the object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the method (without the arguments or brackets) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argTypes</em>&nbsp;</td><td>the list of argument types of the method</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the name of the type that this method will return with the specified argument types.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="elRef" doxygen="qt.tag:" href="qmetatype.html">QMetaType</a> for more information on the Qt meta type system. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="qca__support_8h-source.html">qca_support.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 21 10:27:09 2008 for Qt Cryptographic Architecture by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
