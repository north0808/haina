<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Qt Cryptographic Architecture: saslclient.cpp</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>saslclient.cpp</h1>The code below shows how to create a SASL client.<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> Copyright (C) 2003-2008  Justin Karneges &lt;justin@affinix.com&gt;</span>
<span class="comment"> Copyright (C) 2006  Michail Pishchagin</span>
<span class="comment"></span>
<span class="comment"> Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="comment"> of this software and associated documentation files (the "Software"), to deal</span>
<span class="comment"> in the Software without restriction, including without limitation the rights</span>
<span class="comment"> to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="comment"> copies of the Software, and to permit persons to whom the Software is</span>
<span class="comment"> furnished to do so, subject to the following conditions:</span>
<span class="comment"></span>
<span class="comment"> The above copyright notice and this permission notice shall be included in</span>
<span class="comment"> all copies or substantial portions of the Software.</span>
<span class="comment"></span>
<span class="comment"> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="comment"> IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="comment"> FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE</span>
<span class="comment"> AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</span>
<span class="comment"> AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="comment"> CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="comment">*/</span>

<span class="preprocessor">#include &lt;QCoreApplication&gt;</span>
<span class="preprocessor">#include &lt;QTimer&gt;</span>
<span class="preprocessor">#include &lt;QTcpSocket&gt;</span>
<span class="preprocessor">#include &lt;QTcpServer&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="comment">// QtCrypto has the declarations for all of QCA</span>
<span class="preprocessor">#include &lt;QtCrypto&gt;</span>

<span class="keyword">static</span> <a name="_a0"></a><a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> prompt(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;s)
{
        printf(<span class="stringliteral">"* %s "</span>, qPrintable(s));
        fflush(stdout);
        <span class="keywordtype">char</span> line[256];
        fgets(line, 255, stdin);
        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> result = line;
        <span class="keywordflow">if</span>(result[result.<a name="a1"></a><a class="codeRef" doxygen="qt.tag:" href="qstring.html#length">length</a>()-1] == <span class="charliteral">'\n'</span>)
                result.<a name="a2"></a><a class="codeRef" doxygen="qt.tag:" href="qstring.html#truncate">truncate</a>(result.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#length">length</a>()-1);
        <span class="keywordflow">return</span> result;
}

<span class="keyword">static</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> socketErrorToString(QAbstractSocket::SocketError x)
{
        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> s;
        <span class="keywordflow">switch</span>(x)
        {
                <span class="keywordflow">case</span> QAbstractSocket::ConnectionRefusedError:
                        s = <span class="stringliteral">"connection refused or timed out"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::RemoteHostClosedError:
                        s = <span class="stringliteral">"remote host closed the connection"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::HostNotFoundError:
                        s = <span class="stringliteral">"host not found"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::SocketAccessError:
                        s = <span class="stringliteral">"access error"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::SocketResourceError:
                        s = <span class="stringliteral">"too many sockets"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::SocketTimeoutError:
                        s = <span class="stringliteral">"operation timed out"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::DatagramTooLargeError:
                        s = <span class="stringliteral">"datagram was larger than system limit"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::NetworkError:
                        s = <span class="stringliteral">"network error"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::AddressInUseError:
                        s = <span class="stringliteral">"address is already in use"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::SocketAddressNotAvailableError:
                        s = <span class="stringliteral">"address does not belong to the host"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> QAbstractSocket::UnsupportedSocketOperationError:
                        s = <span class="stringliteral">"operation is not supported by the local operating system"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">default</span>:
                        s = <span class="stringliteral">"unknown socket error"</span>; <span class="keywordflow">break</span>;
        }
        <span class="keywordflow">return</span> s;
}

<span class="keyword">static</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> saslAuthConditionToString(<a class="code" href="classQCA_1_1SASL.html#68bc5ac69884a108b9068bc8e18a2af7" title="Possible authentication error states.">QCA::SASL::AuthCondition</a> x)
{
        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> s;
        <span class="keywordflow">switch</span>(x)
        {
                <span class="keywordflow">case</span> <a name="a3"></a><a class="code" href="classQCA_1_1SASL.html#68bc5ac69884a108b9068bc8e18a2af7ba87543d21c971e78606ab19204b8c8c" title="No compatible/appropriate authentication mechanism.">QCA::SASL::NoMechanism</a>:
                        s = <span class="stringliteral">"no appropriate mechanism could be negotiated"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> <a name="a4"></a><a class="code" href="classQCA_1_1SASL.html#68bc5ac69884a108b9068bc8e18a2af79e2bcedc179699ed6a433f141f58c34a" title="Bad protocol or cancelled.">QCA::SASL::BadProtocol</a>:
                        s = <span class="stringliteral">"bad SASL protocol"</span>; <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> <a name="a5"></a><a class="code" href="classQCA_1_1SASL.html#68bc5ac69884a108b9068bc8e18a2af7be24c72ba5f93880b3ba96c02badc53a" title="Server failed mutual authentication (client side only).">QCA::SASL::BadServer</a>:
                        s = <span class="stringliteral">"server failed mutual authentication"</span>; <span class="keywordflow">break</span>;
                <span class="comment">// AuthFail or unknown (including those defined for server only)</span>
                <span class="keywordflow">default</span>:
                        s = <span class="stringliteral">"generic authentication failure"</span>; <span class="keywordflow">break</span>;
        };
        <span class="keywordflow">return</span> s;
}

<span class="keyword">class </span>ClientTest : <span class="keyword">public</span> <a name="_a6"></a><a class="codeRef" doxygen="qt.tag:" href="qobject.html">QObject</a>
{
        Q_OBJECT

<span class="keyword">private</span>:
        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> host, proto, authzid, realm, user, pass;
        <span class="keywordtype">int</span> port;
        <span class="keywordtype">bool</span> no_authzid, no_realm;
        <span class="keywordtype">int</span> mode; <span class="comment">// 0 = receive mechanism list, 1 = sasl negotiation, 2 = app</span>
        <a name="_a7"></a><a class="codeRef" doxygen="qt.tag:" href="qtcpsocket.html">QTcpSocket</a> *sock;
        <a name="_a8"></a><a class="code" href="classQCA_1_1SASL.html" title="Simple Authentication and Security Layer protocol implementation.">QCA::SASL</a> *sasl;
        <a name="_a9"></a><a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> inbuf;
        <span class="keywordtype">bool</span> sock_done;
        <span class="keywordtype">int</span> waitCycles;

<span class="keyword">public</span>:
        ClientTest(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;_host, <span class="keywordtype">int</span> _port, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;_proto, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;_authzid, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;_realm, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;_user, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;_pass, <span class="keywordtype">bool</span> _no_authzid, <span class="keywordtype">bool</span> _no_realm) :
                host(_host),
                proto(_proto),
                authzid(_authzid),
                realm(_realm),
                user(_user),
                pass(_pass),
                port(_port),
                no_authzid(_no_authzid),
                no_realm(_no_realm),
                sock_done(false),
                waitCycles(0)
        {
                sock = <span class="keyword">new</span> <a class="codeRef" doxygen="qt.tag:" href="qtcpsocket.html">QTcpSocket</a>(<span class="keyword">this</span>);
                <a name="a10"></a><a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sock, SIGNAL(connected()), SLOT(sock_connected()));
                <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sock, SIGNAL(readyRead()), SLOT(sock_readyRead()));
                <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sock, SIGNAL(error(QAbstractSocket::SocketError)), SLOT(sock_error(QAbstractSocket::SocketError)));

                sasl = <span class="keyword">new</span> <a class="code" href="classQCA_1_1SASL.html" title="Simple Authentication and Security Layer protocol implementation.">QCA::SASL</a>(<span class="keyword">this</span>);
                <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sasl, SIGNAL(clientStarted(<span class="keywordtype">bool</span>, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;)), SLOT(sasl_clientFirstStep(<span class="keywordtype">bool</span>, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;)));
                <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sasl, SIGNAL(nextStep(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;)), SLOT(sasl_nextStep(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;)));
                <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sasl, SIGNAL(needParams(<span class="keyword">const</span> <a name="_a11"></a><a class="code" href="classQCA_1_1SASL_1_1Params.html" title="Parameter flags for the SASL authentication.">QCA::SASL::Params</a> &amp;)), SLOT(sasl_needParams(<span class="keyword">const</span> <a class="code" href="classQCA_1_1SASL_1_1Params.html" title="Parameter flags for the SASL authentication.">QCA::SASL::Params</a> &amp;)));
                <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sasl, SIGNAL(authenticated()), SLOT(sasl_authenticated()));
                <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sasl, SIGNAL(readyRead()), SLOT(sasl_readyRead()));
                <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sasl, SIGNAL(readyReadOutgoing()), SLOT(sasl_readyReadOutgoing()));
                <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">connect</a>(sasl, SIGNAL(error()), SLOT(sasl_error()));
        }

<span class="keyword">public</span> slots:
        <span class="keywordtype">void</span> start()
        {
                mode = 0; <span class="comment">// mech list mode</span>

                <span class="keywordtype">int</span> flags = 0;
                flags |= QCA::SASL::AllowPlain;
                flags |= QCA::SASL::AllowAnonymous;
                sasl-&gt;setConstraints((<a class="code" href="classQCA_1_1SASL.html#fadd5c4ed30e4d0ccaa789967aa12684" title="Authentication requirement flag values.">QCA::SASL::AuthFlags</a>)flags, 0, 256);

                <span class="keywordflow">if</span>(!user.isEmpty())
                        sasl-&gt;setUsername(user);
                <span class="keywordflow">if</span>(!authzid.isEmpty())
                        sasl-&gt;setAuthzid(authzid);
                <span class="keywordflow">if</span>(!pass.isEmpty())
                        sasl-&gt;setPassword(pass.toUtf8());
                <span class="keywordflow">if</span>(!realm.isEmpty())
                        sasl-&gt;setRealm(realm);

                printf(<span class="stringliteral">"Connecting to %s:%d, for protocol %s\n"</span>, qPrintable(host), port, qPrintable(proto));
                sock-&gt;connectToHost(host, port);
        }

signals:
        <span class="keywordtype">void</span> quit();

<span class="keyword">private</span> slots:
        <span class="keywordtype">void</span> sock_connected()
        {
                printf(<span class="stringliteral">"Connected to server.  Awaiting mechanism list...\n"</span>);
        }

        <span class="keywordtype">void</span> sock_error(QAbstractSocket::SocketError x)
        {
                <span class="keywordflow">if</span>(x == QAbstractSocket::RemoteHostClosedError)
                {
                        <span class="keywordflow">if</span>(mode == 2) <span class="comment">// app mode, where disconnect means completion</span>
                        {
                                sock_done = <span class="keyword">true</span>;
                                tryFinished();
                                <span class="keywordflow">return</span>;
                        }
                        <span class="keywordflow">else</span> <span class="comment">// any other mode, where disconnect is an error</span>
                        {
                                printf(<span class="stringliteral">"Error: server closed connection unexpectedly.\n"</span>);
                                emit quit();
                                <span class="keywordflow">return</span>;
                        }
                }

                printf(<span class="stringliteral">"Error: socket: %s\n"</span>, qPrintable(socketErrorToString(x)));
                emit quit();
        }

        <span class="keywordtype">void</span> sock_readyRead()
        {
                <span class="keywordflow">if</span>(mode == 2) <span class="comment">// app mode</span>
                {
                        <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> a = sock-&gt;readAll();
                        printf(<span class="stringliteral">"Read %d bytes\n"</span>, a.<a name="a12"></a><a class="codeRef" doxygen="qt.tag:" href="qbytearray.html#size">size</a>());

                        <span class="comment">// there is a possible flaw in the qca 2.0 api, in</span>
                        <span class="comment">//   that if sasl data is received from the peer</span>
                        <span class="comment">//   followed by a disconnect from the peer, there is</span>
                        <span class="comment">//   no clear approach to salvaging the bytes.  tls is</span>
                        <span class="comment">//   not affected because tls has the concept of</span>
                        <span class="comment">//   closing a session.  with sasl, there is no</span>
                        <span class="comment">//   closing, and since the qca api is asynchronous,</span>
                        <span class="comment">//   we could potentially wait forever for decoded</span>
                        <span class="comment">//   data, if the last write was a partial packet.</span>
                        <span class="comment">//</span>
                        <span class="comment">// for now, we can perform a simple workaround of</span>
                        <span class="comment">//   waiting at least three event loop cycles for</span>
                        <span class="comment">//   decoded data before giving up and assuming the</span>
                        <span class="comment">//   last write was partial.  the fact is, all current</span>
                        <span class="comment">//   qca sasl providers respond within this time</span>
                        <span class="comment">//   frame, so this fix should work fine for now.  in</span>
                        <span class="comment">//   qca 2.1, we should revise the api to handle this</span>
                        <span class="comment">//   situation better.</span>
                        <span class="comment">//</span>
                        <span class="comment">// further note: i guess this only affects application</span>
                        <span class="comment">//   protocols that have no close message of their</span>
                        <span class="comment">//   own, and rely on the tcp-level close.  examples</span>
                        <span class="comment">//   are http, and of course this qcatest protocol.</span>
                        <span class="keywordflow">if</span>(waitCycles == 0)
                        {
                                waitCycles = 3;
                                QMetaObject::invokeMethod(<span class="keyword">this</span>, <span class="stringliteral">"waitWriteIncoming"</span>, Qt::QueuedConnection);
                        }

                        sasl-&gt;writeIncoming(a);
                }
                <span class="keywordflow">else</span> <span class="comment">// mech list or sasl negotiation mode</span>
                {
                        <span class="keywordflow">if</span>(sock-&gt;canReadLine())
                        {
                                <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> line = sock-&gt;readLine();
                                line.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#truncate">truncate</a>(line.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#length">length</a>() - 1); <span class="comment">// chop the newline</span>
                                handleLine(line);
                        }
                }
        }

        <span class="keywordtype">void</span> sasl_clientFirstStep(<span class="keywordtype">bool</span> clientInit, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;clientInitData)
        {
                printf(<span class="stringliteral">"Choosing mech: %s\n"</span>, qPrintable(sasl-&gt;mechanism()));
                <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> line = sasl-&gt;mechanism();
                <span class="keywordflow">if</span>(clientInit)
                {
                        line += <span class="charliteral">' '</span>;
                        line += arrayToString(clientInitData);
                }
                sendLine(line);
        }

        <span class="keywordtype">void</span> sasl_nextStep(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;stepData)
        {
                <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> line = <span class="stringliteral">"C"</span>;
                <span class="keywordflow">if</span>(!stepData.<a name="a13"></a><a class="codeRef" doxygen="qt.tag:" href="qbytearray.html#isEmpty">isEmpty</a>())
                {
                        line += <span class="charliteral">','</span>;
                        line += arrayToString(stepData);
                }
                sendLine(line);
        }

        <span class="keywordtype">void</span> sasl_needParams(<span class="keyword">const</span> <a class="code" href="classQCA_1_1SASL_1_1Params.html" title="Parameter flags for the SASL authentication.">QCA::SASL::Params</a> &amp;params)
        {
                <span class="keywordflow">if</span>(params.<a name="a14"></a><a class="code" href="classQCA_1_1SASL_1_1Params.html#7227c4b0ae319a8ab31524fdbd41c95a" title="User is needed.">needUsername</a>())
                {
                        user = prompt(<span class="stringliteral">"Username:"</span>);
                        sasl-&gt;setUsername(user);
                }

                <span class="keywordflow">if</span>(params.<a name="a15"></a><a class="code" href="classQCA_1_1SASL_1_1Params.html#0d894a3c841292cbe512a472694f3d06" title="An Authorization ID can be sent if desired.">canSendAuthzid</a>() &amp;&amp; !no_authzid)
                {
                        authzid = prompt(<span class="stringliteral">"Authorize As (enter to skip):"</span>);
                        <span class="keywordflow">if</span>(!authzid.isEmpty())
                                sasl-&gt;setAuthzid(authzid);
                }

                <span class="keywordflow">if</span>(params.<a name="a16"></a><a class="code" href="classQCA_1_1SASL_1_1Params.html#71793cf357972d30d058685d6f802794" title="Password is needed.">needPassword</a>())
                {
                        <a name="_a17"></a><a class="code" href="classQCA_1_1ConsolePrompt.html" title="Console prompt handler.">QCA::ConsolePrompt</a> prompt;
                        prompt.<a name="a18"></a><a class="code" href="classQCA_1_1ConsolePrompt.html#baeace194f2371abafc0e23ba5fb3274" title="Allow the user to enter data without it being echo&amp;#39;d to the terminal.">getHidden</a>(<span class="stringliteral">"* Password"</span>);
                        prompt.<a name="a19"></a><a class="code" href="classQCA_1_1ConsolePrompt.html#9b8a199fb44d7d9d51978893ad5f7b68" title="Block waiting for user input.">waitForFinished</a>();
                        <a name="_a20"></a><a class="code" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">QCA::SecureArray</a> pass = prompt.<a name="a21"></a><a class="code" href="classQCA_1_1ConsolePrompt.html#2a8be82bf5102b13359f724c31f6a63e" title="Obtain the result of the user input.">result</a>();
                        sasl-&gt;setPassword(pass);
                }

                <span class="keywordflow">if</span>(params.<a name="a22"></a><a class="code" href="classQCA_1_1SASL_1_1Params.html#860baabfb6c3552518d04e450db97d3c" title="A Realm can be sent if desired.">canSendRealm</a>() &amp;&amp; !no_realm)
                {
                        <a name="_a23"></a><a class="codeRef" doxygen="qt.tag:" href="qstringlist.html">QStringList</a> realms = sasl-&gt;realmList();
                        printf(<span class="stringliteral">"Available realms:\n"</span>);
                        <span class="keywordflow">if</span>(realms.isEmpty())
                                printf(<span class="stringliteral">"  (none specified)\n"</span>);
                        <span class="keywordflow">foreach</span>(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;s, realms)
                                printf(<span class="stringliteral">"  %s\n"</span>, qPrintable(s));
                        realm = prompt(<span class="stringliteral">"Realm (enter to skip):"</span>);
                        <span class="keywordflow">if</span>(!realm.isEmpty())
                                sasl-&gt;setRealm(realm);
                }

                sasl-&gt;continueAfterParams();
        }

        <span class="keywordtype">void</span> sasl_authenticated()
        {
                printf(<span class="stringliteral">"SASL success!\n"</span>);
                printf(<span class="stringliteral">"SSF: %d\n"</span>, sasl-&gt;ssf());
        }

        <span class="keywordtype">void</span> sasl_readyRead()
        {
                <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> a = sasl-&gt;read();
                inbuf += a;
                processInbuf();
        }

        <span class="keywordtype">void</span> sasl_readyReadOutgoing()
        {
                <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> a = sasl-&gt;readOutgoing();
                sock-&gt;write(a);
        }

        <span class="keywordtype">void</span> sasl_error()
        {
                <span class="keywordtype">int</span> e = sasl-&gt;errorCode();
                <span class="keywordflow">if</span>(e == <a name="a24"></a><a class="code" href="classQCA_1_1SASL.html#b07944cc39852a622b65ffe1f7a955b329e7edcf6cefa69648894eaa45fff14a" title="problem starting up SASL">QCA::SASL::ErrorInit</a>)
                        printf(<span class="stringliteral">"Error: sasl: initialization failed.\n"</span>);
                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(e == <a name="a25"></a><a class="code" href="classQCA_1_1SASL.html#b07944cc39852a622b65ffe1f7a955b39961501d27ba8cd7fd3d7b4e3a376a4b" title="problem during the authentication process">QCA::SASL::ErrorHandshake</a>)
                        printf(<span class="stringliteral">"Error: sasl: %s.\n"</span>, qPrintable(saslAuthConditionToString(sasl-&gt;authCondition())));
                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(e == <a name="a26"></a><a class="code" href="classQCA_1_1SASL.html#b07944cc39852a622b65ffe1f7a955b32a4f3eb7a2b2cc79ffaf8e96e7a5d43d" title="problem at anytime after">QCA::SASL::ErrorCrypt</a>)
                        printf(<span class="stringliteral">"Error: sasl: broken security layer.\n"</span>);
                <span class="keywordflow">else</span>
                        printf(<span class="stringliteral">"Error: sasl: unknown error.\n"</span>);

                emit quit();
        }

        <span class="keywordtype">void</span> waitWriteIncoming()
        {
                --waitCycles;
                <span class="keywordflow">if</span>(waitCycles &gt; 0)
                {
                        QMetaObject::invokeMethod(<span class="keyword">this</span>, <span class="stringliteral">"waitWriteIncoming"</span>, Qt::QueuedConnection);
                        <span class="keywordflow">return</span>;
                }

                tryFinished();
        }

<span class="keyword">private</span>:
        <span class="keywordtype">void</span> tryFinished()
        {
                <span class="keywordflow">if</span>(sock_done &amp;&amp; waitCycles == 0)
                {
                        printf(<span class="stringliteral">"Finished, server closed connection.\n"</span>);

                        <span class="comment">// if we give up on waiting for a response to</span>
                        <span class="comment">//   writeIncoming, then it might come late.  in</span>
                        <span class="comment">//   theory this shouldn't happen if we wait enough</span>
                        <span class="comment">//   cycles, but if one were to arrive then it could</span>
                        <span class="comment">//   occur between the request to quit the app and</span>
                        <span class="comment">//   the actual quit of the app.  to assist with</span>
                        <span class="comment">//   debugging, then, we'll explicitly stop listening</span>
                        <span class="comment">//   for signals here.  otherwise the response may</span>
                        <span class="comment">//   still be received and displayed, giving a false</span>
                        <span class="comment">//   sense of correctness.</span>
                        sasl-&gt;disconnect(<span class="keyword">this</span>);

                        emit quit();
                }
        }

        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> arrayToString(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> &amp;ba)
        {
                <span class="keywordflow">return</span> <a name="_a27"></a><a class="code" href="classQCA_1_1Base64.html" title="Base64 encoding / decoding">QCA::Base64</a>().arrayToString(ba);
        }

        <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> stringToArray(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;s)
        {
                <span class="keywordflow">return</span> <a class="code" href="classQCA_1_1Base64.html" title="Base64 encoding / decoding">QCA::Base64</a>().stringToArray(s).toByteArray();
        }

        <span class="keywordtype">void</span> sendLine(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;line)
        {
                printf(<span class="stringliteral">"Writing: {%s}\n"</span>, qPrintable(line));
                <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> s = line + <span class="charliteral">'\n'</span>;
                <a class="codeRef" doxygen="qt.tag:" href="qbytearray.html">QByteArray</a> a = s.<a name="a28"></a><a class="codeRef" doxygen="qt.tag:" href="qstring.html#toUtf8">toUtf8</a>();
                <span class="keywordflow">if</span>(mode == 2) <span class="comment">// app mode</span>
                        sasl-&gt;write(a); <span class="comment">// write to sasl</span>
                <span class="keywordflow">else</span> <span class="comment">// mech list or sasl negotiation</span>
                        sock-&gt;write(a); <span class="comment">// write to socket</span>
        }

        <span class="keywordtype">void</span> processInbuf()
        {
                <span class="comment">// collect completed lines from inbuf</span>
                <a class="codeRef" doxygen="qt.tag:" href="qstringlist.html">QStringList</a> list;
                <span class="keywordtype">int</span> at;
                <span class="keywordflow">while</span>((at = inbuf.indexOf(<span class="charliteral">'\n'</span>)) != -1)
                {
                        list += <a name="a29"></a><a class="codeRef" doxygen="qt.tag:" href="qstring.html#fromUtf8">QString::fromUtf8</a>(inbuf.mid(0, at));
                        inbuf = inbuf.mid(at + 1);
                }

                <span class="comment">// process the lines</span>
                <span class="keywordflow">foreach</span>(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;line, list)
                        handleLine(line);
        }

        <span class="keywordtype">void</span> handleLine(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;line)
        {
                printf(<span class="stringliteral">"Reading: [%s]\n"</span>, qPrintable(line));
                <span class="keywordflow">if</span>(mode == 0)
                {
                        <span class="comment">// first line is the method list</span>
                        <a class="codeRef" doxygen="qt.tag:" href="qstringlist.html">QStringList</a> mechlist = line.<a name="a30"></a><a class="codeRef" doxygen="qt.tag:" href="qstring.html#split">split</a>(<span class="charliteral">' '</span>);
                        mode = 1; <span class="comment">// switch to sasl negotiation mode</span>
                        sasl-&gt;startClient(proto, host, mechlist);
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(mode == 1)
                {
                        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> type, rest;
                        <span class="keywordtype">int</span> n = line.<a name="a31"></a><a class="codeRef" doxygen="qt.tag:" href="qstring.html#indexOf">indexOf</a>(<span class="charliteral">','</span>);
                        <span class="keywordflow">if</span>(n != -1)
                        {
                                type = line.<a name="a32"></a><a class="codeRef" doxygen="qt.tag:" href="qstring.html#mid">mid</a>(0, n);
                                rest = line.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#mid">mid</a>(n + 1);
                        }
                        <span class="keywordflow">else</span>
                                type = line;
        
                        <span class="keywordflow">if</span>(type == <span class="stringliteral">"C"</span>)
                        {
                                sasl-&gt;putStep(stringToArray(rest));
                        }
                        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(type == <span class="stringliteral">"E"</span>)
                        {
                                <span class="keywordflow">if</span>(!rest.<a name="a33"></a><a class="codeRef" doxygen="qt.tag:" href="qstring.html#isEmpty">isEmpty</a>())
                                        printf(<span class="stringliteral">"Error: server says: %s.\n"</span>, qPrintable(rest));
                                <span class="keywordflow">else</span>
                                        printf(<span class="stringliteral">"Error: server error, unspecified.\n"</span>);
                                emit quit();
                                <span class="keywordflow">return</span>;
                        }
                        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(type == <span class="stringliteral">"A"</span>)
                        {
                                printf(<span class="stringliteral">"Authentication success.\n"</span>);
                                mode = 2; <span class="comment">// switch to app mode</span>

                                <span class="comment">// at this point, the server may send us text</span>
                                <span class="comment">//   lines for us to display and then close.</span>

                                sock_readyRead(); <span class="comment">// any extra data?</span>
                                <span class="keywordflow">return</span>;
                        }
                        <span class="keywordflow">else</span>
                        {
                                printf(<span class="stringliteral">"Error: Bad format from peer, closing.\n"</span>);
                                emit quit();
                                <span class="keywordflow">return</span>;
                        }
                }
        }
};

<span class="keywordtype">void</span> usage()
{
        printf(<span class="stringliteral">"usage: saslclient (options) host(:port) (user) (pass)\n"</span>);
        printf(<span class="stringliteral">"options: --proto=x, --authzid=x, --realm=x\n"</span>);
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
        <a name="_a34"></a><a class="code" href="classQCA_1_1Initializer.html" title="Convenience method for initialising and cleaning up QCA.">QCA::Initializer</a> <a name="a35"></a><a class="code" href="namespaceQCA.html#4dc8db9c7ef2a40aff9c2d2760f49458" title="This is an overloaded member function, provided for convenience. It differs from...">init</a>;
        <a name="_a36"></a><a class="codeRef" doxygen="qt.tag:" href="qcoreapplication.html">QCoreApplication</a> qapp(argc, argv);

        <a class="codeRef" doxygen="qt.tag:" href="qstringlist.html">QStringList</a> args = qapp.arguments();
        args.removeFirst();

        <span class="comment">// options</span>
        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> proto = <span class="stringliteral">"qcatest"</span>; <span class="comment">// default protocol</span>
        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> authzid, realm;
        <span class="keywordtype">bool</span> no_authzid = <span class="keyword">false</span>;
        <span class="keywordtype">bool</span> no_realm = <span class="keyword">false</span>;
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; args.count(); ++n)
        {
                <span class="keywordflow">if</span>(!args[n].startsWith(<span class="stringliteral">"--"</span>))
                        <span class="keywordflow">continue</span>;

                <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> opt = args[n].mid(2);
                <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> var, val;
                <span class="keywordtype">int</span> at = opt.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#indexOf">indexOf</a>(<span class="charliteral">'='</span>);
                <span class="keywordflow">if</span>(at != -1)
                {
                        var = opt.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#mid">mid</a>(0, at);
                        val = opt.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#mid">mid</a>(at + 1);
                }
                <span class="keywordflow">else</span>
                        var = opt;

                <span class="keywordflow">if</span>(var == <span class="stringliteral">"proto"</span>)
                {
                        proto = val;
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(var == <span class="stringliteral">"authzid"</span>)
                {
                        <span class="comment">// specifying empty authzid means force unspecified</span>
                        <span class="keywordflow">if</span>(val.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#isEmpty">isEmpty</a>())
                                no_authzid = <span class="keyword">true</span>;
                        <span class="keywordflow">else</span>
                                authzid = val;
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(var == <span class="stringliteral">"realm"</span>)
                {
                        <span class="comment">// specifying empty realm means force unspecified</span>
                        <span class="keywordflow">if</span>(val.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#isEmpty">isEmpty</a>())
                                no_realm = <span class="keyword">true</span>;
                        <span class="keywordflow">else</span>
                                realm = val;
                }

                args.removeAt(n);
                --n; <span class="comment">// adjust position</span>
        }

        <span class="keywordflow">if</span>(args.count() &lt; 1)
        {
                usage();
                <span class="keywordflow">return</span> 0;
        }

        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> host, user, pass;
        <span class="keywordtype">int</span> port = 8001; <span class="comment">// default port</span>

        <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> hostinput = args[0];
        <span class="keywordflow">if</span>(args.count() &gt;= 2)
                user = args[1];
        <span class="keywordflow">if</span>(args.count() &gt;= 3)
                pass = args[2];

        <span class="keywordtype">int</span> at = hostinput.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#indexOf">indexOf</a>(<span class="charliteral">':'</span>);
        <span class="keywordflow">if</span>(at != -1)
        {
                host = hostinput.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#mid">mid</a>(0, at);
                port = hostinput.<a class="codeRef" doxygen="qt.tag:" href="qstring.html#mid">mid</a>(at + 1).toInt();
        }
        <span class="keywordflow">else</span>
                host = hostinput;

        <span class="keywordflow">if</span>(!<a name="a37"></a><a class="code" href="namespaceQCA.html#833c9f215544113d52a3a52eedc58620" title="Test if a capability (algorithm) is available.">QCA::isSupported</a>(<span class="stringliteral">"sasl"</span>))
        {
                printf(<span class="stringliteral">"Error: SASL support not found.\n"</span>);
                <span class="keywordflow">return</span> 1;
        }

        ClientTest client(host, port, proto, authzid, realm, user, pass, no_authzid, no_realm);
        <a class="codeRef" doxygen="qt.tag:" href="qobject.html#connect">QObject::connect</a>(&amp;client, SIGNAL(quit()), &amp;qapp, SLOT(quit()));
        <a name="a38"></a><a class="codeRef" doxygen="qt.tag:" href="qtimer.html#singleShot">QTimer::singleShot</a>(0, &amp;client, SLOT(start()));
        qapp.exec();

        <span class="keywordflow">return</span> 0;
}

<span class="preprocessor">#include "saslclient.moc"</span>
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 21 10:26:53 2008 for Qt Cryptographic Architecture by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
