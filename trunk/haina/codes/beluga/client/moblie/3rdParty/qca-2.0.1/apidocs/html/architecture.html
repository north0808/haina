<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Qt Cryptographic Architecture: Architecture</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="architecture">Architecture </a></h1><dl class="note" compact><dt><b>Note:</b></dt><dd>You don't need to understand any of this to use QCA - it is documented for those who are curious, and for anyone planning to extend or modify QCA.</dd></dl>
The design of QCA is based on the Bridge design pattern. The intent of the Bridge pattern is to "Decouple an abstraction from its implementation so that the two can vary independently." [Gamma et.al, pg 151].<p>
To understand how this decoupling works in the case of QCA, is is easiest to look at an example - a cryptographic Hash. The API is pretty simple (although I've left out some parts that aren't required for this example):<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>QCA_EXPORT Hash : <span class="keyword">public</span> Algorithm, <span class="keyword">public</span> BufferedComputation
{
<span class="keyword">public</span>:
    Hash(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;type, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;provider);
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear();
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> update(<span class="keyword">const</span> <a class="code" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">QCA::SecureArray</a> &amp;a);
    <span class="keyword">virtual</span> <a class="code" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">QCA::SecureArray</a> <span class="keyword">final</span>();
}
</pre></div><p>
The implementation for the Hash class is almost as simple:<p>
<div class="fragment"><pre class="fragment">Hash::Hash(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;type, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;provider)
:Algorithm(type, provider)
{
}

<span class="keywordtype">void</span> <a class="code" href="classQCA_1_1Hash.html#ad9e4eb96f7c5fd93f1cd8b3092755de" title="Reset a hash, dumping all previous parts of the message.">Hash::clear</a>()
{
        <span class="keyword">static_cast&lt;</span>HashContext *<span class="keyword">&gt;</span>(context())-&gt;clear();
}

<span class="keywordtype">void</span> <a class="code" href="classQCA_1_1Hash.html#91efd04d2a310e75b6a8f1baffa86f9f" title="Update a hash, adding more of the message contents to the digest.">Hash::update</a>(<span class="keyword">const</span> <a class="code" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">QCA::SecureArray</a> &amp;a)
{
        <span class="keyword">static_cast&lt;</span>HashContext *<span class="keyword">&gt;</span>(context())-&gt;update(a);
}

<a class="code" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">QCA::SecureArray</a> <a class="code" href="classQCA_1_1Hash.html#9b1e200b130e7631dc284f89046e891f" title="Finalises input and returns the hash result.">Hash::final</a>()
{
        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>HashContext *<span class="keyword">&gt;</span>(context())-&gt;<span class="keyword">final</span>();
}
</pre></div><p>
The reason why it looks so simple is that the various methods in Hash just call out to equivalent routines in the context() object. The context comes from a call (getContext()) that is made as part of the Algorithm constructor. That getContext() call causes QCA to work through the list of providers (generally plugins) that it knows about, looking for a provider that can produce the right kind of context (in this case, a HashContext).<p>
The code for a HashContext doesn't need to be linked into QCA - it can be varied in its implementation, including being changed at run-time. The application doesn't need to know how HashContext is implemented, because it just has to deal with the Hash class interface. In fact, HashContext may not be implemented, so the application should check (using <a class="el" href="namespaceQCA.html#833c9f215544113d52a3a52eedc58620" title="Test if a capability (algorithm) is available.">QCA::isSupported()</a>) before trying to use features that are implemented with plugins.<p>
The code for one implementation (in this case, calling OpenSSL) is shown below. <div class="fragment"><pre class="fragment"><span class="keyword">class </span>opensslHashContext : <span class="keyword">public</span> HashContext
{
<span class="keyword">public</span>:
    opensslHashContext(<span class="keyword">const</span> EVP_MD *algorithm, Provider *p, <span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;type) : HashContext(p, type)
    {
        m_algorithm = algorithm;
        EVP_DigestInit( &amp;m_context, m_algorithm );
    };

    ~opensslHashContext()
    {
        EVP_MD_CTX_cleanup(&amp;m_context);
    }

    <span class="keywordtype">void</span> clear()
    {
        EVP_MD_CTX_cleanup(&amp;m_context);
        EVP_DigestInit( &amp;m_context, m_algorithm );
    }

    <span class="keywordtype">void</span> update(<span class="keyword">const</span> <a class="code" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">QCA::SecureArray</a> &amp;a)
    {
        EVP_DigestUpdate( &amp;m_context, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)a.<a class="code" href="classQCA_1_1SecureArray.html#8054bb6b6bd72d30a07344b3a7645553" title="Pointer to the data in the secure array.">data</a>(), a.<a class="code" href="classQCA_1_1SecureArray.html#6414d576761db18707321698bd4cb401" title="Returns the number of bytes in the array.">size</a>() );
    }

    <a class="code" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">QCA::SecureArray</a> <span class="keyword">final</span>()
    {
        <a class="code" href="classQCA_1_1SecureArray.html" title="Secure array of bytes.">QCA::SecureArray</a> a( EVP_MD_size( m_algorithm ) );
        EVP_DigestFinal( &amp;m_context, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)a.<a class="code" href="classQCA_1_1SecureArray.html#8054bb6b6bd72d30a07344b3a7645553" title="Pointer to the data in the secure array.">data</a>(), 0 );
        <span class="keywordflow">return</span> a;
    }

    Provider::Context *clone()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslHashContext(*<span class="keyword">this</span>);
    }

<span class="keyword">protected</span>:
    <span class="keyword">const</span> EVP_MD *m_algorithm;
    EVP_MD_CTX m_context;
};
</pre></div><p>
This approach (using an Adapter pattern) is very common in QCA backends, because the plugins are often based on existing libraries.<p>
In addition to the various Context objects, each provider also has a parameterised Factory class that has a createContext() method, as shown below: <div class="fragment"><pre class="fragment">        Context *createContext(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;type)
        {
                <span class="comment">//OpenSSL_add_all_digests();</span>
                <span class="keywordflow">if</span> ( type == <span class="stringliteral">"sha1"</span> )
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslHashContext( EVP_sha1(), <span class="keyword">this</span>, type);
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( type == <span class="stringliteral">"sha0"</span> )
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslHashContext( EVP_sha(), <span class="keyword">this</span>, type);
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( type == <span class="stringliteral">"md5"</span> )
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslHashContext( EVP_md5(), <span class="keyword">this</span>, type);
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( type == <span class="stringliteral">"aes128-cfb"</span> )
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslCipherContext( EVP_aes_128_cfb(), 0, <span class="keyword">this</span>, type);
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( type == <span class="stringliteral">"aes128-cbc"</span> )
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslCipherContext( EVP_aes_128_cbc(), 0, <span class="keyword">this</span>, type);
                <span class="keywordflow">else</span>
                        <span class="keywordflow">return</span> 0;
        }
</pre></div><p>
The resulting effect is that QCA can ask the provider to provide an appropriate Context object without worrying about how it is implemented.<p>
For features that are implemented with variable algorithms (for example, HashContext can support a wide range of algorithms - MD5, SHA0, and SHA1 in the example above; and CipherContext and MACContext can also do this), we need to be able to let applications determine which algorithms are supported. This is handled through the InfoContext class. A typical example is shown below: <div class="fragment"><pre class="fragment">        <span class="keyword">class </span>opensslInfoContext : <span class="keyword">public</span> InfoContext
        {
                Q_OBJECT
        <span class="keyword">public</span>:
                opensslInfoContext(Provider *p) : InfoContext(p)
                {
                }

                Context *clone()<span class="keyword"> const</span>
<span class="keyword">                </span>{
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslInfoContext(*<span class="keyword">this</span>);
                }

                <a class="codeRef" doxygen="qt.tag:" href="qstringlist.html">QStringList</a> supportedHashTypes()<span class="keyword"> const</span>
<span class="keyword">                </span>{
                        <a class="codeRef" doxygen="qt.tag:" href="qstringlist.html">QStringList</a> list;
                        list += <span class="stringliteral">"sha1"</span>;
                        list += <span class="stringliteral">"sha0"</span>;
                        list += <span class="stringliteral">"md5"</span>;
                        <span class="keywordflow">return</span> list;
                }

                <span class="comment">// MAC and Cipher types can go in here</span>
        };
</pre></div><p>
Note that InfoContext is itself a feature, so you have to add it to the createContext() method for the provider, as shown below: <div class="fragment"><pre class="fragment">        Context *createContext(<span class="keyword">const</span> <a class="codeRef" doxygen="qt.tag:" href="qstring.html">QString</a> &amp;type)
        {
                <span class="keywordflow">if</span> ( type == <span class="stringliteral">"sha1"</span> )
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslHashContext( EVP_sha1(), <span class="keyword">this</span>, type);
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( type == <span class="stringliteral">"sha0"</span> )
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslHashContext( EVP_sha(), <span class="keyword">this</span>, type);
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( type == <span class="stringliteral">"md5"</span> )
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslHashContext( EVP_md5(), <span class="keyword">this</span>, type);
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( type == <span class="stringliteral">"info"</span> )
                        <span class="keywordflow">return</span> <span class="keyword">new</span> opensslInfoContext( <span class="keyword">this</span> );
                <span class="keywordflow">else</span>
                        <span class="keywordflow">return</span> 0;
        }
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 21 10:26:56 2008 for Qt Cryptographic Architecture by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
